
module.exports = function(RED) {
    "use strict";
    var reconnect = RED.settings.mysqlReconnectTime || 20000;
    var mysqldb = require('mysql');
	var fs = require('fs');
	var host = "";
	var port = 0;
	var user = "";
	var pass = "";
	var database = "";
	host = JSON.parse(process.env.myDB).host;
	port = JSON.parse(process.env.myDB).port;
	database = JSON.parse(process.env.myDB).dbname;
	user = JSON.parse(process.env.myDB).credentials.user;
	pass = JSON.parse(process.env.myDB).credentials.password;
	
	var isUpdate = false;
    function MySQLNode(n) {
		RED.nodes.createNode(this,n);
        this.connected = false;
        this.connecting = false;
        this.setMaxListeners(0);
        var node = this;

        function checkVer() {
            node.connection.query("SELECT version();", [], function(err, rows) {
                if (err) {
                    node.connection.release();
                    node.error(err);
                    node.status({fill:"red",shape:"ring",text:"Bad Ping"});
                    doConnect();
                }
            });
        }

        function doConnect() {
            node.connecting = true;
            node.emit("state","connecting");
            if (!node.pool || isUpdate) {
                node.pool = mysqldb.createPool({
                    host : host,
                    port : port,
                    user : user,
                    password : pass,
                    database : database,
                    timezone : "local",
                    insecureAuth: true,
                    multipleStatements: true,
                    connectionLimit: 25
                });
            }

            node.pool.getConnection(function(err, connection) {
                node.connecting = false;
                if (err) {
                    node.emit("state",err.code);
                    node.error(err);
                    node.tick = setTimeout(doConnect, reconnect);
                }
                else {
                    node.connection = connection;
                    node.connected = true;
                    node.emit("state","connected");
					isUpdate = false;
                    node.connection.on('error', function(err) {
                        node.connected = false;
                        node.connection.release();
                        node.emit("state",err.code);
                        if (err.code === 'PROTOCOL_CONNECTION_LOST') {
                            doConnect(); // silently reconnect...
                        }
                        else if (err.code === 'ECONNRESET') {
                            doConnect(); // silently reconnect...
                        }
                        else {
                            node.error(err);
                            doConnect();
                        }
                    });
                    if (!node.check) { node.check = setInterval(checkVer, 290000); }
                }
            });
        }
	
		this.update = function(m_host, m_port, m_user, m_pass, m_database){
			if(m_host !== host || m_port !== port || m_user !== user || m_pass !== pass || m_database !== database || node.connected === false) {
				host = m_host;
				port = m_port;
				user = m_user;
				pass = m_pass;
				database = m_database;
				node.connected = false;
				if (this.tick) { clearTimeout(this.tick); }
				if (this.check) { clearInterval(this.check); }
				isUpdate = true;
				doConnect();
			}
		}
        this.connect = function() {
            if (!this.connected && !this.connecting) {
                doConnect();
            }
        }

        this.on('close', function (done) {
            if (this.tick) { clearTimeout(this.tick); }
            if (this.check) { clearInterval(this.check); }
            node.connected = false;
            node.connection.release();
            node.emit("state"," ");
            node.pool.end(function (err) { done(); });
        });
    }
    RED.nodes.registerType("MySQLdatabaseTSDV",MySQLNode, {
    });


    function MysqlDBNodeIn(n) {
        RED.nodes.createNode(this,n);
        this.mydb = n.mydb;
        this.mydbConfig = RED.nodes.getNode(this.mydb);
        this.status({});

        if (this.mydbConfig) {
            this.mydbConfig.connect();
            var node = this;
            var busy = false;
            var status = {};
            node.mydbConfig.on("state", function(info) {
                if (info === "connecting") { node.status({fill:"grey",shape:"ring",text:info}); }
                else if (info === "connected") { node.status({fill:"green",shape:"dot",text:info}); }
                else {
                    if (info === "ECONNREFUSED") { info = "connection refused"; }
                    if (info === "PROTOCOL_CONNECTION_LOST") { info = "connection lost"; }
                    node.status({fill:"red",shape:"ring",text:info});
                }
            });

            node.on("input", function(msg) {
				if(msg.host !== undefined && msg.port !== undefined && msg.user !== undefined && msg.password !== undefined && msg.database !== undefined) {
					node.mydbConfig.update(msg.host, msg.port, msg.user, msg.password, msg.database);
					return;
				}
                if (node.mydbConfig.connected) {
                    if (typeof msg.topic === 'string') {
                        console.log("query:",msg.topic);
                        var bind = [];
                        if (Array.isArray(msg.payload)) { bind = msg.payload; }
                        else if (typeof msg.payload === 'object' && msg.payload !== null) {
                            bind=msg.payload;
                            node.mydbConfig.connection.config.queryFormat = function (query, values) {
                                if (!values){
                                    return query;
                                }
                                return query.replace(/\:(\w+)/g, function (txt, key) {
                                    if (values.hasOwnProperty(key)) {
                                        return this.escape(values[key]);
                                    }
                                return txt;
                                }.bind(this));
                            };          
                        }
                        node.mydbConfig.connection.query(msg.topic, bind, function(err, rows) {
                            if (err) {
                                status = {fill:"red",shape:"ring",text:"Error: "+err.code};
                                node.status(status);
                                node.error(err,msg);
                            }
                            else {
                                if (rows.constructor.name === "OkPacket") {
                                    msg.payload = JSON.parse(JSON.stringify(rows));
                                }
                                else { msg.payload = rows; }
                                node.send(msg);
                                status = {fill:"green",shape:"dot",text:"OK"};
                                node.status(status);
                            }
                        });
                    }
                    else {
                        if (typeof msg.topic !== 'string') { node.error("msg.topic : the query is not defined as a string"); }
                    }
                }
                else {
                    node.error("Database not connected",msg);
                    status = {fill:"red",shape:"ring",text:"not yet connected"};
                }
                if (!busy) {
                    busy = true;
                    node.status(status);
                    node.tout = setTimeout(function() { busy = false; node.status(status); },500);
                }
            });

            node.on('close', function () {
                if (node.tout) { clearTimeout(node.tout); }
                node.mydbConfig.removeAllListeners();
                node.status({});
            });
        }
        else {
            this.error("MySQL database not configured");
        }
    }
    RED.nodes.registerType("mysqlTSDV",MysqlDBNodeIn);
}
